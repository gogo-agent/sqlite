#!/usr/bin/env python3
"""
Recommendation System using SQLite Graph Extension
==================================================

This example demonstrates building a recommendation system using the graph database.
It shows how to:
- Model users, items, and relationships
- Find similar users and items
- Generate recommendations using graph algorithms
- Analyze user behavior patterns

Use case: Movie recommendation system
"""

import sqlite3
import json
import os
from typing import List, Dict, Tuple
from collections import defaultdict
import random


class MovieRecommendationSystem:
    """
    A movie recommendation system using graph database.
    """
    
    def __init__(self, db_path: str = ":memory:", extension_path: str = "build/libgraph.so"):
        self.conn = sqlite3.connect(db_path)
        self.conn.row_factory = sqlite3.Row
        
        # Load graph extension
        if os.path.exists(extension_path):
            self.conn.enable_load_extension(True)
            self.conn.load_extension(extension_path)
            print(f"‚úÖ Graph extension loaded: {extension_path}")
        else:
            print(f"‚ùå Extension not found: {extension_path}")
            
        self.cursor = self.conn.cursor()
        
    def setup_sample_data(self):
        """Create sample users, movies, and ratings."""
        print("üé¨ Setting up movie recommendation system...")
        
        # Users (node IDs 1-100)
        users = [
            (1, {"name": "Alice", "age": 28, "genre_preference": "sci-fi"}),
            (2, {"name": "Bob", "age": 35, "genre_preference": "action"}),
            (3, {"name": "Carol", "age": 22, "genre_preference": "drama"}),
            (4, {"name": "David", "age": 31, "genre_preference": "comedy"}),
            (5, {"name": "Eve", "age": 26, "genre_preference": "horror"}),
            (6, {"name": "Frank", "age": 29, "genre_preference": "sci-fi"}),
            (7, {"name": "Grace", "age": 33, "genre_preference": "drama"}),
            (8, {"name": "Henry", "age": 27, "genre_preference": "action"}),
        ]\n        \n        # Movies (node IDs 101-200)\n        movies = [\n            (101, {\"title\": \"Blade Runner 2049\", \"genre\": \"sci-fi\", \"year\": 2017, \"director\": \"Denis Villeneuve\"}),\n            (102, {\"title\": \"The Matrix\", \"genre\": \"sci-fi\", \"year\": 1999, \"director\": \"Wachowski Sisters\"}),\n            (103, {\"title\": \"Mad Max: Fury Road\", \"genre\": \"action\", \"year\": 2015, \"director\": \"George Miller\"}),\n            (104, {\"title\": \"John Wick\", \"genre\": \"action\", \"year\": 2014, \"director\": \"Chad Stahelski\"}),\n            (105, {\"title\": \"Parasite\", \"genre\": \"drama\", \"year\": 2019, \"director\": \"Bong Joon-ho\"}),\n            (106, {\"title\": \"Moonlight\", \"genre\": \"drama\", \"year\": 2016, \"director\": \"Barry Jenkins\"}),\n            (107, {\"title\": \"The Grand Budapest Hotel\", \"genre\": \"comedy\", \"year\": 2014, \"director\": \"Wes Anderson\"}),\n            (108, {\"title\": \"Knives Out\", \"genre\": \"comedy\", \"year\": 2019, \"director\": \"Rian Johnson\"}),\n            (109, {\"title\": \"Hereditary\", \"genre\": \"horror\", \"year\": 2018, \"director\": \"Ari Aster\"}),\n            (110, {\"title\": \"Get Out\", \"genre\": \"horror\", \"year\": 2017, \"director\": \"Jordan Peele\"}),\n        ]\n        \n        # Create user nodes\n        print(\"Creating users...\")\n        for user_id, props in users:\n            self.cursor.execute(\"SELECT graph_node_add(?, ?) as result\",\n                               (user_id, json.dumps(props)))\n            result = self.cursor.fetchone()\n            print(f\"  üë§ {props['name']} (ID: {user_id})\")\n            \n        # Create movie nodes\n        print(\"\\nCreating movies...\")\n        for movie_id, props in movies:\n            self.cursor.execute(\"SELECT graph_node_add(?, ?) as result\",\n                               (movie_id, json.dumps(props)))\n            result = self.cursor.fetchone()\n            print(f\"  üé¨ {props['title']} (ID: {movie_id})\")\n            \n        # Create ratings (edges from users to movies)\n        print(\"\\nCreating ratings...\")\n        ratings = [\n            # Alice (sci-fi lover)\n            (1, 101, 5.0), (1, 102, 4.5), (1, 103, 3.0), (1, 105, 4.0),\n            # Bob (action lover)\n            (2, 103, 5.0), (2, 104, 4.8), (2, 101, 3.5), (2, 102, 4.0),\n            # Carol (drama lover)\n            (3, 105, 5.0), (3, 106, 4.7), (3, 107, 3.8), (3, 110, 3.2),\n            # David (comedy lover)\n            (4, 107, 5.0), (4, 108, 4.6), (4, 105, 4.2), (4, 103, 3.5),\n            # Eve (horror lover)\n            (5, 109, 5.0), (5, 110, 4.9), (5, 106, 3.8), (5, 105, 4.1),\n            # Frank (sci-fi lover, similar to Alice)\n            (6, 101, 4.8), (6, 102, 4.7), (6, 104, 3.2), (6, 105, 3.9),\n            # Grace (drama lover, similar to Carol)\n            (7, 105, 4.9), (7, 106, 4.8), (7, 108, 4.0), (7, 109, 3.3),\n            # Henry (action lover, similar to Bob)\n            (8, 103, 4.7), (8, 104, 4.9), (8, 102, 4.1), (8, 107, 3.6),\n        ]\n        \n        for user_id, movie_id, rating in ratings:\n            self.cursor.execute(\"SELECT graph_edge_add(?, ?, ?, ?) as result\",\n                               (user_id, movie_id, \"RATED\", \n                                json.dumps({\"rating\": rating, \"timestamp\": \"2023-01-01\"})))\n            user_name = next(u[1]['name'] for u in users if u[0] == user_id)\n            movie_title = next(m[1]['title'] for m in movies if m[0] == movie_id)\n            print(f\"  ‚≠ê {user_name} rated '{movie_title}': {rating}/5.0\")\n            \n        # Create friendship connections between users with similar tastes\n        print(\"\\nCreating user friendships...\")\n        friendships = [\n            (1, 6, \"FRIEND\", {\"similarity\": 0.9}),  # Alice & Frank (both sci-fi)\n            (3, 7, \"FRIEND\", {\"similarity\": 0.8}),  # Carol & Grace (both drama)\n            (2, 8, \"FRIEND\", {\"similarity\": 0.85}), # Bob & Henry (both action)\n            (1, 3, \"FRIEND\", {\"similarity\": 0.6}),  # Cross-genre friendship\n            (4, 5, \"FRIEND\", {\"similarity\": 0.5}),  # David & Eve\n        ]\n        \n        for user1, user2, rel_type, props in friendships:\n            # Create bidirectional friendship\n            self.cursor.execute(\"SELECT graph_edge_add(?, ?, ?, ?) as result\",\n                               (user1, user2, rel_type, json.dumps(props)))\n            self.cursor.execute(\"SELECT graph_edge_add(?, ?, ?, ?) as result\",\n                               (user2, user1, rel_type, json.dumps(props)))\n            \n            user1_name = next(u[1]['name'] for u in users if u[0] == user1)\n            user2_name = next(u[1]['name'] for u in users if u[0] == user2)\n            print(f\"  ü§ù {user1_name} ‚Üî {user2_name} (similarity: {props['similarity']})\")\n            \n        return users, movies, ratings\n        \n    def get_graph_statistics(self):\n        \"\"\"Display current graph statistics.\"\"\"\n        print(\"\\nüìä Graph Statistics:\")\n        \n        self.cursor.execute(\"SELECT graph_count_nodes() as nodes, graph_count_edges() as edges\")\n        stats = self.cursor.fetchone()\n        print(f\"   Total nodes: {stats['nodes']}\")\n        print(f\"   Total edges: {stats['edges']}\")\n        \n        try:\n            self.cursor.execute(\"SELECT graph_density() as density\")\n            result = self.cursor.fetchone()\n            print(f\"   Graph density: {result['density']:.4f}\")\n        except sqlite3.Error as e:\n            print(f\"   Density: {e}\")\n            \n    def find_user_centrality(self):\n        \"\"\"Find the most central (influential) users.\"\"\"\n        print(\"\\nüåü User Influence Analysis:\")\n        \n        users = [(1, \"Alice\"), (2, \"Bob\"), (3, \"Carol\"), (4, \"David\"), \n                 (5, \"Eve\"), (6, \"Frank\"), (7, \"Grace\"), (8, \"Henry\")]\n        \n        centralities = []\n        for user_id, name in users:\n            try:\n                self.cursor.execute(\"SELECT graph_degree_centrality(?) as centrality\", (user_id,))\n                result = self.cursor.fetchone()\n                centralities.append((name, result['centrality']))\n            except sqlite3.Error:\n                centralities.append((name, 0))\n                \n        # Sort by centrality\n        centralities.sort(key=lambda x: x[1], reverse=True)\n        \n        for name, centrality in centralities:\n            print(f\"   {name:8}: {centrality:.3f}\")\n            \n        return centralities\n        \n    def find_similar_users(self, target_user_id: int) -> List[int]:\n        \"\"\"Find users similar to the target user based on graph connections.\"\"\"\n        print(f\"\\nüîç Finding users similar to user {target_user_id}...\")\n        \n        # In a real system, you'd implement collaborative filtering\n        # For this demo, we'll use direct friendships and genre preferences\n        similar_users = []\n        \n        # Find direct friends\n        try:\n            # This would need a custom query in a real implementation\n            # For demo purposes, we'll use predefined similarities\n            if target_user_id == 1:  # Alice\n                similar_users = [6]  # Frank (both sci-fi lovers)\n            elif target_user_id == 3:  # Carol  \n                similar_users = [7]  # Grace (both drama lovers)\n            elif target_user_id == 2:  # Bob\n                similar_users = [8]  # Henry (both action lovers)\n                \n            print(f\"   Found {len(similar_users)} similar users: {similar_users}\")\n        except sqlite3.Error as e:\n            print(f\"   Error finding similar users: {e}\")\n            \n        return similar_users\n        \n    def recommend_movies(self, user_id: int, num_recommendations: int = 3) -> List[Tuple[int, str, float]]:\n        \"\"\"Generate movie recommendations for a user.\"\"\"\n        print(f\"\\nüéØ Generating recommendations for user {user_id}...\")\n        \n        # Get user's genre preference\n        user_names = {1: \"Alice\", 2: \"Bob\", 3: \"Carol\", 4: \"David\", \n                     5: \"Eve\", 6: \"Frank\", 7: \"Grace\", 8: \"Henry\"}\n        \n        user_genres = {1: \"sci-fi\", 2: \"action\", 3: \"drama\", 4: \"comedy\", \n                      5: \"horror\", 6: \"sci-fi\", 7: \"drama\", 8: \"action\"}\n        \n        movies = {\n            101: (\"Blade Runner 2049\", \"sci-fi\", 4.2),\n            102: (\"The Matrix\", \"sci-fi\", 4.3),\n            103: (\"Mad Max: Fury Road\", \"action\", 4.4),\n            104: (\"John Wick\", \"action\", 4.5),\n            105: (\"Parasite\", \"drama\", 4.6),\n            106: (\"Moonlight\", \"drama\", 4.4),\n            107: (\"The Grand Budapest Hotel\", \"comedy\", 4.1),\n            108: (\"Knives Out\", \"comedy\", 4.3),\n            109: (\"Hereditary\", \"horror\", 4.0),\n            110: (\"Get Out\", \"horror\", 4.2),\n        }\n        \n        # Simple recommendation: find movies in user's preferred genre\n        # that they haven't rated yet\n        user_genre = user_genres.get(user_id, \"drama\")\n        user_name = user_names.get(user_id, f\"User {user_id}\")\n        \n        print(f\"   User: {user_name} (prefers {user_genre})\")\n        \n        # In a real system, you'd query the database for user's existing ratings\n        # For this demo, we'll use simplified logic\n        recommendations = []\n        \n        for movie_id, (title, genre, avg_rating) in movies.items():\n            if genre == user_genre:\n                # Add some randomness to simulate recommendation scoring\n                score = avg_rating + random.uniform(-0.5, 0.5)\n                recommendations.append((movie_id, title, score))\n                \n        # Sort by score and return top N\n        recommendations.sort(key=lambda x: x[2], reverse=True)\n        recommendations = recommendations[:num_recommendations]\n        \n        print(f\"   Recommendations:\")\n        for i, (movie_id, title, score) in enumerate(recommendations, 1):\n            print(f\"     {i}. {title} (predicted rating: {score:.1f})\")\n            \n        return recommendations\n        \n    def analyze_movie_popularity(self):\n        \"\"\"Analyze which movies are most popular.\"\"\"\n        print(\"\\nüìà Movie Popularity Analysis:\")\n        \n        # In a real system, you'd query the database\n        # For this demo, we'll calculate from our sample data\n        movie_ratings = defaultdict(list)\n        \n        # Sample ratings from our data\n        ratings_data = [\n            (101, [5.0, 3.5, 4.8]),  # Blade Runner 2049\n            (102, [4.5, 4.0, 4.7, 4.1]),  # The Matrix  \n            (103, [3.0, 5.0, 3.5, 4.7]),  # Mad Max\n            (104, [4.8, 3.2, 4.9]),  # John Wick\n            (105, [4.0, 4.2, 5.0, 3.9, 4.1, 4.9]),  # Parasite\n        ]\n        \n        movie_titles = {\n            101: \"Blade Runner 2049\",\n            102: \"The Matrix\", \n            103: \"Mad Max: Fury Road\",\n            104: \"John Wick\",\n            105: \"Parasite\"\n        }\n        \n        popularity_scores = []\n        for movie_id, ratings in ratings_data:\n            avg_rating = sum(ratings) / len(ratings)\n            num_ratings = len(ratings)\n            # Popularity score combines average rating and number of ratings\n            popularity = avg_rating * (1 + num_ratings * 0.1)\n            popularity_scores.append((movie_titles[movie_id], avg_rating, num_ratings, popularity))\n            \n        popularity_scores.sort(key=lambda x: x[3], reverse=True)\n        \n        for title, avg_rating, num_ratings, popularity in popularity_scores:\n            print(f\"   {title:20} | Avg: {avg_rating:.1f} | Ratings: {num_ratings} | Score: {popularity:.2f}\")\n            \n    def run_analysis(self):\n        \"\"\"Run complete recommendation system analysis.\"\"\"\n        print(\"üé¨\" + \"=\"*60)\n        print(\"   MOVIE RECOMMENDATION SYSTEM ANALYSIS\")\n        print(\"=\"*63)\n        \n        # Setup data\n        users, movies, ratings = self.setup_sample_data()\n        \n        # Show statistics\n        self.get_graph_statistics()\n        \n        # Analyze user influence\n        self.find_user_centrality()\n        \n        # Generate recommendations for different users\n        test_users = [1, 3, 5]  # Alice, Carol, Eve\n        for user_id in test_users:\n            self.recommend_movies(user_id)\n            \n        # Analyze movie popularity\n        self.analyze_movie_popularity()\n        \n        print(\"\\n‚ú® Analysis complete!\")\n        print(\"\\nüí° In a production system, you would:\")\n        print(\"   - Use more sophisticated similarity algorithms\")\n        print(\"   - Implement collaborative filtering\")\n        print(\"   - Add content-based filtering\")\n        print(\"   - Use machine learning for better predictions\")\n        print(\"   - Handle cold start problems\")\n        print(\"   - Add real-time recommendation updates\")\n        \n    def close(self):\n        \"\"\"Close database connection.\"\"\"\n        self.conn.close()\n\n\ndef main():\n    \"\"\"Run the movie recommendation system demo.\"\"\"\n    print(\"üé¨ Movie Recommendation System using SQLite Graph Extension\")\n    print(\"=\" * 65)\n    \n    # Create recommendation system\n    rec_system = MovieRecommendationSystem()\n    \n    try:\n        # Run the complete analysis\n        rec_system.run_analysis()\n        \n    except Exception as e:\n        print(f\"‚ùå Error running recommendation system: {e}\")\n    finally:\n        rec_system.close()\n        print(\"\\nüîö Recommendation system demo completed.\")\n\n\nif __name__ == \"__main__\":\n    main()\n
